## System Call 시스템 콜

<br/>

> Process가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해주는 기능.
> 
> 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다. 보통 C나 C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다.


### 시스템 콜의 유형

크게 프로세스 제어, 파일 관리, 장치 관리, 정보 유지보수, 통신과 보호의 5가지로 나눌 수 있다.


1. 프로세스 제어

   - 프로세스 생성 및 종료
   - 메모리에 로드, 실행
   - 프로세스 속성 값 확인, 지정
   - wait 이벤트, signal 이벤트
   - 메모리 할당


2. 파일 관리

   - 파일 생성, 파일 삭제
   - 열기, 닫기
   - 읽기, 쓰기, Reposition
   - 파일 속성 값 확인, 지정


3. 디바이스 관리

   - 디바이스 요청 및 해제
   - 읽기, 쓰기, Reposition
   - 디바이스 속성 확인, 지정
   - 비 물리적인 디바이스 해제 및 장착


4. 정보 유지보수

   - 시간 확인, 시간 지정
   - 시스템 데이터 확인, 지정
   - 프로세스, 파일, 디바이스 속성 가져오기
   - 프로세스, 파일, 디바이스 속성 설정하기


5. 통신과 보안

   통신
   - 커뮤니케이션 연결 생성 및 삭제
   - 메시지 송신, 수신
   - 상태 정보 전달
   - remote 디바이스 해제 및 장착
   보안
   - Permission 획득
   - Permission 설정



<br/>
<br/>

### 실제 유닉스와 윈도우에서의 코드 구현
<image src ="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcA9in9%2Fbtqw9OAIYdZ%2FkKNVkBl0y9k9R3EjTNyNI0%2Fimg.png" />

<br/>
<br/>

### 각 명령어 설명


<br/>

1. fork() - 자식 프로세스 생성

    > 새로운 프로세스를 생성하는 시스템 콜. 
    > 
    > 가상 주소 공간(주소 레지스터 값)을 그대로 복사하기 때문에 주소 레지스터 값이 같음. 새롭게 생성된 자식 프로세스는 새로운 PID를 갖게되며 호출한 부모 프로세스를 그대로 복사함. 복사를 통해 자식 프로세스는 부모와 완전히 독립된 물리 메모리 공간을 가짐.(주소 레지스터 값이 같다고 해서 실제 물리 메모리 주소가 같지는 않음)
   
   <br/>
   
   ``` c
   #include <unistd.h>
   
   pid_t fork(void);
   ```

    - 리턴값
      - 성공
        - 자식: 0
        - 부모: 자식의 PID
      - 실패: -1 리턴하고 errno 설정


<br/>

2. wait() - 자식 프로세스의 종료 대기

   > 자식 프로세스가 종료되기 전까지 부모 프로세스를 기다리게 하는 시스템 콜
   > 
   > 좀비 프로세스를 회수하고 고아 프로세스가 되는 것을 방지함.

   <br/>
   
   
   ``` c
   #include <sys/wait.h>
   
   pid_t wait(int *stat_loc);
   ```

   <br/>
   
   - 리턴값
      - 성공: 종료된 자식 프로세스의 PID 리턴
      - 실패: -1 리턴
    
   <br/>
   
    > 좀비 프로세스: 프로세스가 종료되면 모든 메모리가 회수 되지 않고 일부가 남아 있게됨. 이때 부모 프로세스가 wait() 시스템 콜을 호출해주지 않으면 계속 좀비 프로세스 상태로 남음.
    > 
    > 고아 프로세스: 자식 프로세스가 종료되기 전에 부모 프로세스가 먼저 종료될 경우 고아 프로세스가 . 따라서 자식 프로세스를 생성한 경우에 반드시 wait() 시스템 콜을 호출해야함.


<br/>

3. exec() - 프로세스 변환

   > fork()로 자식 프로세스 생성 후child에서는 parent와 다른 동작을 하고 싶을 때 exec를 사용함. (일반 fork()는 같은 동작을 반복하게됨)

   <br/>
   
   ``` c
    #include <unistd.h>
    
    int execve(const char *pathname, char *const argv[], char *const envp[]);
   ```

   <br/>
   
   - 리턴값
      - 성공: 리턴하지 않음
      - 에러: -1 리턴하고 errno 설정

   <br/>

   >  #### 자식 프로세스를 만드는 이유? 
   > 
   > 첫번째는 sh 프로세스가 직접 exec()를 호출하면 완전 다른 프로세스로 변환되기 때문에 프로세스 유지가 불가능하기 때문.
   > 두번째는 sh 프로세스를 유지함으로서 파이프(||)나 리디렉션(>, >>, >&, <) 등을 처리하기 위해서.
   
