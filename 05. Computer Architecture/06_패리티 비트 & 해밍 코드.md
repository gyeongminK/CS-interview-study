## 패리티 비트

- **개념**
    
    > 정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트를 말한다.
    > 
    > 
    > 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송한다.
    
<br>

- **종류**
    
    > 짝수(Even Parity), 홀수(Odd Parity)
    > 
    > 
    > 전체 비트에서 (짝수, 홀수)에 맞도록 비트를 정한다.
 
 <br>
 
- **예시**
    
    ![Untitled (1)](https://user-images.githubusercontent.com/61955796/166140233-f3198868-8146-4299-b9ba-d49ff8fdc0e7.png)
    
    위처럼 8-Bit의 데이터 외에 추가적으로 패리티 비트 하나를 추가하여 송수신
    

    ![Untitled (2)](https://user-images.githubusercontent.com/61955796/166140257-57cf71b8-f399-41de-b58e-f85b4aeac3a0.png)

    짝수 패리티로 설정할 것인지 혹은 홀수 패리티로 설정할 것인지에 따라서 **붙는 패리티 비트의 값이 달라진다**. (짝수 패리티가 0이고 홀수 패리티가 1인 것은 아님)<br><br>

    **짝수(Even) 패리티**는 실제 송신하고자 하는 데이터의 각 비트의 값 중에서 **1의 개수가 짝수가 되도록 패리티 비트를 정하는 것이다. <br>
    (**ex. 데이터 비트에서 1의 개수가 홀수이면 패리티 비트를 1로 정함)<br><br>

    위의 그림에서는 데이터의 각 비트의 값 중 1의 개수가 이미 짝수이므로 **짝수 패리티 비트의 값이 0으로 설정되어 있다.**<br><br>

    **홀수(Odd) 패리티**는 전체 비트에서 **1의 개수가 홀수**가 되도록 패리티 비트를 정하는 방법이다. <br>
    위의 그림을 봤을 때 1의 개수가 짝수이므로, 이를 홀수로 맞추기 위해서 **홀수 패리티 비트의 값을 1로 설정**한다.
    
 <br>


- **응용**
    
    ***짝수 패리티일 때 7비트 데이터가 1010001라면?***
    
    > 1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야 함
    > 
    > 
    > 답 : 11010001 (맨앞이 패리티비트)
    > 
<br>

- **사용 이유**
    
    > 데이터를 송수신하는 과정에서 각 비트를 단위 시간당 하나씩 보내는데 이때 알 수 없는 요인에 의해서 비트의 값이 틀어져 1이 0으로 바뀌거나 0이 1로 바뀌었을 때 이를 확인할 수 있도록 하기 위해서이다.
    
    > 즉, 패리티 비트를 정하여 데이터를 보내면 받는 쪽에서는 수신된 데이터의 전체 비트를 계산하여 패리티 비트를 다시 계산함으로써 **데이터 오류 발생 여부를 알 수 있다**. 그러나 오류를 **수정할 수는 없고** **2개의 bit 오류가 발생**했을 경우는 검출할 수 없다.
    > 

<br>

- **사용하는 경우**
    
    > **시리얼 통신의 거리가 상당히 멀 경우**에 주로 적용된다.
    
    > 송수신 거리가 짧을 경우에는 보통의 경우 패리티 비트는 사용하지 않고, **Checksum 데이터**를 추가한다.
  
<br><br><br>

## 해밍 코드

- **개념**
    
    > 데이터 전송 시 오류 검출과 정정을 할 수 있는 코드이다.
    패리티 비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있다. 
    즉, **에러 비트의 위치를 알 수 있을 뿐만 아니라 정정**할 수 있다!
    
<br>

- **공식**
    
    ![Untitled (3)](https://user-images.githubusercontent.com/61955796/166140358-d6304603-9b23-4fd6-ba6d-adb5e8da7f1b.png)
    
    위 공식을 만족하는 p값이어야 하는데, 데이터 비트가 1byte일 때 8bit이므로 p는 최소 4가 되어야 한다.
    
    <br>
    
- **삽입 위치**
    
    Little Endian 포맷 
    
    ![Untitled (4)](https://user-images.githubusercontent.com/61955796/166140396-738d8b30-c8f8-46eb-808c-1738f4ca077f.png)
    
    총 비트 수는 데이터 8비트, 체크 비트 4비트로 12비트이다.
    
    체크 비트가 4개인데 각 체크 비트는 2^ 위치에 삽입된다 (1, 2, 4, 8 ...)
    
    ![Untitled (5)](https://user-images.githubusercontent.com/61955796/166140401-329f58b7-28cb-46ed-b169-8b8347a5d79e.png)
    
    체크 비트를 각 위치에 삽입한 후,
    
    ![Untitled (6)](https://user-images.githubusercontent.com/61955796/166140404-104d125f-4980-46be-898a-974f3e1b37de.png)
    
    나머지 비트를 순서대로 채워준다. 
    
    수신단에서의 데이터스트림은 이와 같은 형식이 되며 각각의 체크 비트들은 할당된 부분에 패리티 체킹을 수행한다.
    
<br>

- **패리티 체킹**
    
    송신된 신호를 기반으로 체크 비트를 모아 놓으면 0101, 0111 등의 비트가 나온다.
    
    그 다음 실제 수신된 체크 비트과 비교하여 에러를 확인한다.
    
    예를 들어, **송신된 신호의 체크비트열은 0011** 인데, **수신된 체크비트가 1001**일 경우에
    
    리틀 엔디안 순서에서 **두 번째 비트**와 **네 번째 비트**에서 기대값과 다른 값이 수신된 결과다.
    
    따라서 오류 확인 비트는 **1010**이 될 것이다. 
    
    이 때 이 수를 Decimal로 읽으면 에러가 생긴 비트를 확인할 수 있다.
    
    1010 = 10이므로, 10번째 비트에 오류가 생긴 것!! 
    
    즉 **수신단에서 D10을 뒤집으면 오류를 정정**할 수 있다.
 
 <br>
    
- **예제**
    
    **10011010** 8비트를 수신한다고 가정한다. (짝수 패리티 사용) <br>
    
    ***1) 전송할 코드어 생성***
    
    <img width="685" alt="Untitled (7)" src="https://user-images.githubusercontent.com/61955796/166140447-25603323-dde5-4977-8227-d34f572668f0.png">
    
    **p1**: 1비트 검사, 1비트 건너뜀. 1비트 검사, 1비트 건너뜀을 반복한다. (1, 3, 5, 7, 9, 11 ...)
    
    1이 4개 있기 때문에 짝수라서 p1에 0을 삽입한다.
    
    <img width="608" alt="Untitled (8)" src="https://user-images.githubusercontent.com/61955796/166140470-a0cce19d-20b5-4f3e-990a-92b6f39535a7.png">
    
    **p2**: 2비트 검사, 2비트 건너뜀. 2비트 검사, 2비트 건너뜀을 반복한다. (2, 3, 6, 7, 10, 11 ...)
    
    1이 3개 있기 때문에 홀수라서 p2에는 1을 삽입한다. 
    
    <img width="603" alt="Untitled (9)" src="https://user-images.githubusercontent.com/61955796/166140476-04e19d8d-a78d-4ca0-ba78-a7227148fae2.png">
    
    **p4**: 4비트 검사, 4비트 건너뜀. 4비트 검사, 4비트 건너뜀을 반복한다. (4, 5, 6, 7, 12 ...)
    
    1이 1개 있기 때문에 홀수라서 p4에 1을 삽입한다.
    
    <img width="604" alt="Untitled (10)" src="https://user-images.githubusercontent.com/61955796/166140500-d4f25304-9d99-46e6-a38e-fe37cca9010a.png">
    
    **p8**: 8비트 검사, 8비트 건너뜀은 반복한다. (8, 9, 10, 11, 12 ...)
    
    1이 2개 있기 때문에 p8에 0을 삽입한다.
    
    전송할 코드어는 다음과 같다.
    
    <img width="604" alt="Untitled (11)" src="https://user-images.githubusercontent.com/61955796/166140505-b98fac35-637a-4eb3-80d3-d12b3ccfaea8.png">
    
    <br>
    
    ***2) 오류 검출과 수정***
    
    d10에서 오류가 검출됐다고 가정한다. (우리는 아직 모르는 상태)
    
    <img width="608" alt="Untitled (12)" src="https://user-images.githubusercontent.com/61955796/166140512-6554af73-82c7-4b77-9d79-2ad0e5277e33.png">
    
    p1을 검사한다. (O)
    
    d3, d5, d7, d9, d11을 확인했을 때 1 0 1 1 1 으로 1이 4개라서 p1은 0이 맞다.
    
    p2를 검사한다. (X)
    
    d3, d6, d7, d10, d11을 확인했을 때 1 0 1 1 1 으로 1이 4개라 p2가 0이어야 하는데 1이라 오류다.
    
    p4를 검사한다. (O)
    
    d5, d6, d7, d12를 확인했을 때 0 0 1 0 으로 1이 1개라 p4가 1이 맞다.
    
    p8을 검사한다. (X)
    
    d9, d10, d11, d12를 확인했을 때 1 1 1 0으로 1이 3개라 p8이 1이어야 하는데 0이라 오류다.
    
    <br>
    
    ***3) 오류 수정***
    
    <img width="608" alt="Untitled (13)" src="https://user-images.githubusercontent.com/61955796/166140523-9111350c-96e8-4f7e-b95d-61d812b6cdb3.png">
    
    p2, p8이 잘못된 값이므로 2 + 8이 10인 10번째 비트에서 오류가 발생했음을 알 수 있다.
    
    따라서 d10의 1을 0으로 바꾸면 오류 해결!!!
    

---

<참고>

[https://dololak.tistory.com/33](https://dololak.tistory.com/33)

[https://m.blog.naver.com/ggggamang/221113176831](https://m.blog.naver.com/ggggamang/221113176831)

[https://dreamlog.tistory.com/578](https://dreamlog.tistory.com/578)
